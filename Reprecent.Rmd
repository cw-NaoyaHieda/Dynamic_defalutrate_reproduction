---
title: "Repuroduction"
author: "Naoya Hieda"
date: "2017年4月19日"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning = FALSE,message = FALSE)

library(dplyr)
library(reshape2)
library(ggplot2)
library(car)
library(normtest)
theme_set(theme_bw())
```

#3.Emrical Implementation

## 大雑把な内容
## 2章で変換されたデフォルト率が従うモデルを示した。
## 自己相関ありとなしの場合で、6つのローンカテゴリーのデータをモデルに当てはめる。
## カテゴリーはそれぞれ、米国の不動産、クレジットカード、それ以外のローン、リース、保険、農業

[Federal Reserve Board charge-off-data](https://www.federalreserve.gov/releases/chargeoff/chgallsa.htm)

## データの読み込みと必要なデータの抜き出し
## 年率換算されているので四半期毎の値に戻して、LGDの値で除算
## 各期の純粋なデフォルト率のデータになっているはず
```{r}
charge_off_data <- read.table('data/N_FRB_CHGDEL.csv',encoding='utf-8',sep=',')


#ネット上とcsvで列の順番が違うので注意
repro_data <- charge_off_data[7:98,c(5,9,10,8,4,3)] %>% apply(2,as.numeric)
colnames(repro_data) <- c('RE','CC','OC','L','CI','A')
#各シリーズのLGD(Loss given defalut を除算) データが年率に変換されているのでそこも修正
LGD <- c(0.35,0.65,0.65,0.45,0.45,0.45)
co_data <- t(repro_data)/4/LGD
co_data <- ts(t(co_data), frequency = 4, start = c(1985,1))
#ちょっと強引に四半期時系列生成
date <- time(co_data) %>% c() %>% as.numeric()
ggplot(co_data %>% melt,aes(x=date[Var1],y=value))+geom_line()+
  facet_wrap(~Var2,scales="free_y",ncol=3)+
  xlab('Year')+ylab('Defalut Rate(%)')
colMeans(co_data)
sqrt(colMeans(co_data^2)-colMeans(co_data)^2)
```

### 見た目も平均も、論文のものとはちょっとだけずれてしまう
### 元データが、論文のころは四半期でそのまま表示されていたが、現在は各期の値が年率換算されているため。
### ボラティリティは比較的近い値になった
### なぜか2005年4月Aのデフォルト率がマイナス扱いなので、1e-10にしておく
### この後のAに関する計算結果はずっとおかしいけどしょうがない
```{r}
co_data[co_data<0] <- 1e-10
```
### 元のデータを小数点表示に直してから 単純に標準正規分布cdfの逆数$\Phi^{-1}$で変換したもの
```{r}
pnorm_co_data <- qnorm(co_data/100)
```
### regression on constant が lm(r ~ 0)で実装できるようなので
```{r}
Regression_on_constant <- {}
for(i in 1:6){
tmp <- data.frame(y = pnorm_co_data[,i])
fit <- lm(y ~ 0,data=tmp)
Regression_on_constant <- c(Regression_on_constant,list(summary(fit)))
}
```
### 回帰誤差ボラティリティ(残差の標準偏差)
```{r}
Regression_residual_volatility <- sapply(Regression_on_constant,function(x)sqrt(var(x$residuals)))
```
## beta=0で(24)(25)が成り立っていると考えればいい?
$$
\tilde{\theta}_t=\sqrt{\beta}\tilde{\theta}_{t-1}+\frac{(1-\sqrt{\beta})}{\sqrt{1-\rho}}\Phi^{-1}(q)-\frac{\sqrt{\rho}\sqrt{1-\beta}}{\sqrt{1-\rho}}\eta_t\\
\tilde{\theta_t} = \Phi^{-1}(\theta_t)\sim N(\sqrt{\beta}\tilde{\theta}_{t-1}+\frac{(1-\sqrt{\beta})}{\sqrt{1-\rho}}\Phi^{-1}(q),\frac{\rho(1-\beta)}{1-\rho})\\
\\\\
\beta=0のとき,\\
\tilde{\theta}=\frac{1}{\sqrt{1-\rho}}\Phi^{-1}(q)-\frac{\sqrt{\rho}}{\sqrt{1-\rho}}\eta_t\\
\tilde{\theta} = N(\frac{1}{\sqrt{1-\rho}}\Phi^{-1}(q),\frac{\rho}{1-\rho})
$$

## ニュートン法で最適化 分散から相関係数$\rho$を推定して、平均から無条件デフォルト確率qを推定する
```{r}
factor_correlation <- c()
for(sd_2 in Regression_residual_volatility^2){
  f <- function (rho) sd_2 - rho/(1-rho)
  factor_correlation <- c(factor_correlation,uniroot(f,c(0,1-1e-10))$root)
}
un_defalut_rate <- c()
for(i in c(1:6)){
  f <- function (q) qnorm(q)/sqrt(1 - factor_correlation[i]) - colMeans(pnorm_co_data)[i]
  un_defalut_rate <- c(un_defalut_rate,uniroot(f,c(0,1-1e-10))$root)
}
```
## 論文と同じ表形式で表示
```{r}
table_1 <- t(data.frame(Regression_residual_volatility*100,factor_correlation*100,0,un_defalut_rate*100,0))
colnames(table_1) <-  c('RE','CC','OC','L','CI','A')
rownames(table_1) <- c('Regression_residual_volatility(%)','factor_correlation(%)','std_error_rho(%)','un_defalut_rate(%)','std_error_q(%)')
table_1
```
Stderrorはどうやって計算するのか見当がつかなかったので保留  


### 後々使うので、$X_t$を計算しておく
```{r}
X_t_noauto<- t((qnorm(un_defalut_rate)-sqrt(1-factor_correlation)*t(pnorm_co_data))/sqrt(factor_correlation))
```



### 自己相関を持つ場合を考えるので(25)の$\beta\neq0$で考える
### 一期前の値に対して線形回帰
```{r}
Regression_AR <- {}
for(i in 1:6){
tmp <- data.frame(y = pnorm_co_data[2:92,i],x = pnorm_co_data[1:91,i])
fit <- lm(y ~ x ,data=tmp)
Regression_AR <- c(Regression_AR,list(summary(fit)))
}
```
### 回帰誤差ボラティリティ(残差の標準偏差)は先程と同じように取り出せる
### $\beta$は回帰の係数
### $\rho$は分散からの最適化で先ほどと同じ
### qは式が複雑になるが先ほどと同じ
```{r}
Regression_residual_volatility <- sapply(Regression_AR,function(x)sqrt(var(x$residuals)))
beta_ <- sapply(Regression_AR,function(x) x$coefficients['x','Estimate']^2)
beta_error <- sapply(Regression_AR,function(x) x$coefficients['x','Std. Error'])
factor_correlation <- c()
for(i in 1:6){
  f <- function (rho) sqrt((Regression_residual_volatility[i]^2 - rho*(1-beta_[i])/(1-rho))^2)
  factor_correlation <- c(factor_correlation,optimize(f,c(0,1-1e-10))$minimum)
}
un_defalut_rate <- c()
for(i in c(1:6)){
  f <- function(q)
    -sum(log(dnorm((
      pnorm_co_data[2:92,i]-
        sqrt(beta_[i])*pnorm_co_data[1:91,i]-
        ((1-sqrt(beta_[i]))/sqrt(1-factor_correlation[i]))*qnorm(q))
      )))
  un_defalut_rate <- c(un_defalut_rate,optimize(f, c(0+1e-10,1-1e-10), tol = 0.0001)$minimum)
}

table_2 <- t(data.frame(Regression_residual_volatility*100,factor_correlation*100,0,un_defalut_rate*100,0,beta_*100,beta_error*100))
colnames(table_2) <-  c('RE','CC','OC','L','CI','A')
rownames(table_2) <- c('Regression_residual_volatility(%)','factor_correlation(%)','std_error_rho(%)','un_defalut_rate(%)','std_error_q(%)','beta(%)','std_error_beta(%)')
table_2
```

# 4 Factors and Correlations

## 4.1 Specification Tests
### $\eta_t$のプロット　式に従って計算

式(33)を変換したものと、と式(34)から$\eta_t$を計算
$$
\tilde{\theta_t} = \frac{\Phi(q)^{-1} - \sqrt{\rho}X_t}{\sqrt{1-\rho}} から\\
X_t = \frac{\Phi(q)^{-1}-\sqrt{1-\rho}\tilde{\theta_t}}{\sqrt{\rho}} \\
\eta_t = \frac{X_t-\sqrt{\beta}X_{t-1}}{\sqrt{1-\beta}}
$$
```{r}
X_t_auto<- t((qnorm(un_defalut_rate)-sqrt(1-factor_correlation)*t(pnorm_co_data))/sqrt(factor_correlation))
plot_d <- t((t(X_t_auto[2:92,])-sqrt(beta_)*t(X_t_auto[1:91,]))/sqrt(1-beta_))

data.frame(dt=date[-length(date)],plot_d) %>% melt(id='dt') %>% ggplot(aes(x=dt,y=value)) + geom_line() + facet_wrap(~variable,ncol=3,scales = 'free_y') + xlab('Year') + ylab('Factor Shock Value')
```

### Durbin-Watoson-Testを用いて、回帰の残差における自己相関を検定する。
[Durbin-Watoson-Test](http://business.nikkeibp.co.jp/atclbdt/15/recipe/121100041/?ST=print)

### Jarque-Bera-Testを用いて、歪度と尖度が正規性の値から統計的に有意に異なるか検定する。モンテカルロ計算らしいがこっちは明らかに表と値が違う。
[Jarque-Bera-Test](https://ja.wikipedia.org/wiki/%E3%82%B8%E3%83%A3%E3%83%83%E3%82%AF%E2%80%93%E3%83%99%E3%83%A9%E6%A4%9C%E5%AE%9A)
```{r}
DW_test <- sapply(Regression_AR,function(x) durbinWatsonTest(x$residuals))
DW_test
JB_test <- sapply(Regression_AR,function(x) ajb.norm.test(x$residuals,nrepl = 1000)['statistic'])
t(JB_test)
```

## 4.2 Factor Correlations

### 自己相関ありとなしのそれぞれの相関行列
### なしはそれっぽいけど、ありが全体的におかしい
```{r}
no_auto_cor <- cor(X_t_noauto)
auto_cor <- cor(X_t_auto)
no_auto_cor
auto_cor
```



