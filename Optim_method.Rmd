---
title: "Optimize_method"
author: "Naoya Hieda"
date: "2017年4月22日"
output:
  html_document:
    css: styles.css
---

# "Nelder-Mead" 法
関数値だけを用い、頑健(例えば初期値の選択に敏感でない)であるが、相対的に遅い。微分できない関数に対してもそれなりに使える


>n + 1 個の頂点からなる n 次元の単体（シンプレックス）をアメーバのように動かしながら関数の最小値を探索する。反射、膨張、収縮の3種類を使い分けながら探索する。
>線形計画法の1つであるシンプレックス法と名前はまぎらわしいが、基本的に無関係である。


# "BFGS" 法 
準ニュートン法
variable metric 法とも呼ばれる。関数値とグラディエント関数を最適化関数の曲面を近似するのに使う。Broyden, letcher, Goldfarb, Shanno の4人が同時期に提案。

>通常のニュートン法は最適解の近傍が二次関数で近似できると仮定し、一階および二階の導関数を解の探索に用いる。高次元空間上で定義される関数に対しては、最小化(最大化)したい関数の勾配ベクトルおよびヘッセ行列を用いる。一方で、準ニュートン法ではヘッセ行列を陽に計算する必要がない。その代わりにヘッセ行列が最適化の繰り返し計算の過程で得られる勾配ベクトルにより近似される。準ニュートン法は多次元関数の零点 (関数の値が0となる場所) を探すアルゴリズムの一種であるセカント法（割線法）の一般化であると見ることも出来る。多次元の問題においてはセカント方程式は1次元の場合と違い一意に定まらず、劣決定問題となるが、準ニュートン法は近似の制約が異なっており、具体的には現在の推定ヘッセ行列を低ランク行列成分を用いて更新する。

$$
s_k=x_{k+1}-x_k,y_k=\nabla f(x_{k+1})-\nabla f(x_k)\\
とおいたとき\\
B_{k+1}=B_k+\frac{y_k y_k^\top}{y_k^\top s_k}-\frac{B_k s_k s_k^\top B_k^\top}{s_k^\top B_k s_k}\\
をヘッセ行列の近似と考える
$$
この逆行列の$H_k$を用いて、$d_k=-H_k\nabla f(x_k)$が探索方向となる。逆行列そのものを近似する場合は以下の式により求まる。

$$
H_{k+1}=H_k+\left(1+\frac{y_k^\top H_k y_k}{y_k^\top s_k}\right)\frac{s_k s_k^\top}{y_k^\top s_k}-\frac{H_k y_k s_k^\top + s_k y_k^\top H_k^\top}{y_k^\top s_k}
$$

# "CG" 法 
Fletcher and Reeves による共役勾配法
Polak-Ribiere と Beale-Sorenson による更新法も選択できる共役勾配法は準ニュートン法に比べると破綻しやすいが、メモリー使用量が少ないため、より大規模の最適化に使える可能性

>対称正定値行列を係数とする連立一次方程式を解くためのアルゴリズムである。反復法として利用され、コレスキー分解のような直接法では大きすぎて取り扱えない、大規模な疎行列を解くために利用される。そのような問題は偏微分方程式などを数値的に解く際に常に現れる。

# "L-BFGS-B" 法 
各変数が上限・下限による制約条件を許す準ニュートン法の変種。初期値はこの制約条件を満たす必要がある

# "SANN" 法 
確率的手法であるいわゆるシミュレーテッド・アニーリング法。関数値だけを用い遅い。微分できない関数にも使える。メトロポリス法を用いる。組合せ的最適化問題(巨大な有限集合内から最適値を探す)にも使える。一般的手法ではないが、非常にラフな関数に対しても良い値を得ることができる可能性がある

# "Brend法"
デッカー法に修正を加えた方法  
デッカー法は  

>方程式 f(x) = 0 の解を求めたいとする。まず、、f(a0) と f(b0) が互いに逆符号を持つような a0 と b0 の2点を初期値とする。f が区間 [a0, b0] で連続であるとき、中間値の定理により、a0 と b0の間に解が存在する。
>収束計算において、以下の3点が用いられる：
>bk は現在の収束値、つまりその時点で推定される f の解。
>ak は "反対点"、つまり f(ak) と f(bk) が逆符号を持つような点であり、したがって区間 [ak, bk] に解が含まれる。また、|f(bk)| は |f(ak)| と等しいか、またはより小さい値とする。したがって bk は akよりも求める解に近い。
>bk−1 は1つ前の収束値（最初の収束計算では bk−1 = a0 とする。)
>次の収束値を求めるため、2つの値が計算される。1つは割線法により以下の式で求められ、
$$s = b_k - \frac{b_k-b_{k-1}}{f(b_k)-f(b_{k-1})} f(b_k), $$
>2つめは二分法により求められる。
$$m = \frac{a_k+b_k}{2}$$
>割線法を用いた場合、s は bk と m の間にあり、次の収束値となり (bk+1 = s)、そうでない場合は中間点が使用される。 (bk+1 = m)
>そして、f(ak+1) と f(bk+1) とが逆符号を持つような、新しい反対点が選ばれる。f(ak) と f(bk+1) が逆符号である場合、反対点は移動せず ak+1 = ak となる。両者が同符号であれば、f(bk+1) と f(bk) が逆符号となり、新たな反対点は ak+1 = bk となる。
>最終的に、|f(ak+1)| < |f(bk+1)| となった場合は、 ak+1 は bk+1 よりよい収束値となり、その結果 ak+1 と bk+1 の値が交換される。
以上がデッカー法による1つの収束計算である。